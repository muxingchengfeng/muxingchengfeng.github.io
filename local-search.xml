<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SegmentTree(单点修改区间查询)</title>
    <link href="/2024/08/02/SegmentTree-%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2/"/>
    <url>/2024/08/02/SegmentTree-%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="SegmentTree（单点修改区间查询，不含懒标记）"><a href="#SegmentTree（单点修改区间查询，不含懒标记）" class="headerlink" title="SegmentTree（单点修改区间查询，不含懒标记）"></a>SegmentTree（单点修改区间查询，不含懒标记）</h1><p>定义结构体 $Info$ 并重载其加号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;Info&gt; info;<br><br>    <span class="hljs-built_in">SegmentTree</span>()<br>    &#123;<br>    &#125;<br><br>    <span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> n, Info _init = <span class="hljs-built_in">Info</span>())<br>    &#123;<br>        <span class="hljs-built_in">init</span>(std::<span class="hljs-built_in">vector</span>&lt;Info&gt;(n, _init));<br>    &#125;<br><br>    <span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">const</span> std::vector&lt;Info&gt; &amp;_init)<br>    &#123;<br>        <span class="hljs-built_in">init</span>(_init);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;Info&gt; &amp;_init)</span></span><br><span class="hljs-function">    </span>&#123;<br>        n = (<span class="hljs-type">int</span>)_init.<span class="hljs-built_in">size</span>();<br>        info.<span class="hljs-built_in">assign</span>((n &lt;&lt; <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>, <span class="hljs-built_in">Info</span>());<br>        std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; build = [&amp;](<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<br>            <span class="hljs-keyword">if</span> (l == r) &#123;<br>                info[p] = _init[l - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span> * p, l, m);<br>            <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>, r);<br>            <span class="hljs-built_in">pull</span>(p);<br>        &#125;;<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pull</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        info[p] = info[<span class="hljs-number">2</span> * p] + info[<span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">const</span> Info &amp;v)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            info[p] = v;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (x &lt;= m) &#123;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">2</span> * p, l, m, x, v);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>, r, x, v);<br>        &#125;<br>        <span class="hljs-built_in">pull</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">const</span> Info &amp;v)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, p, v);<br>    &#125;<br><br>    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; y || r &lt; x) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Info</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;<br>            <span class="hljs-keyword">return</span> info[p];<br>        &#125;<br>        <span class="hljs-type">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">2</span> * p, l, m, x, y) + <span class="hljs-built_in">query</span>(<span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>, r, x, y);<br>    &#125;<br><br>    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>&#125;;<br><br>Info <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Info &amp;a, <span class="hljs-type">const</span> Info &amp;b)<br>&#123;<br>    Info res;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>竞赛</category>
      
      <category>算法和模板</category>
      
      <category>数据结构</category>
      
      <category>线段树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>经典5 Sum over Subsets(子集和问题)</title>
    <link href="/2024/07/27/%E7%BB%8F%E5%85%B85-Sum-over-Subsets-%E5%AD%90%E9%9B%86%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/27/%E7%BB%8F%E5%85%B85-Sum-over-Subsets-%E5%AD%90%E9%9B%86%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Sum-over-Subsets-子集和问题-与SOSDP"><a href="#Sum-over-Subsets-子集和问题-与SOSDP" class="headerlink" title="Sum over Subsets(子集和问题)与SOSDP"></a>Sum over Subsets(子集和问题)与SOSDP</h1><p>对于二进制数 $𝑥,𝑦$ ，若 $x &amp; y&#x3D;y$，那么我们称 $𝑥$ 是 $𝑦$ 的子集，$𝑦$ 是 $𝑥$ 的超集。</p><p>假设现在有 $0∼2^𝑛−1$ 这 $2^𝑛$ 个二进制数，每个数都有一个初始权值，如何维护每个二进制数的子集和？</p><p>暴力的有 $𝑂(3^𝑛)$ 写法。</p><p>使用 $SOSPDP$ 可以将时间复杂度降为 $O(n2^n)$ 。</p><p>转移方程为：$dp[i] &#x3D; dp[i] + dp[i\oplus(1 &lt;&lt; j)]$ 。</p><p>这个方法不仅仅可用于求子集和问题，同时也可以进行子集状态的转移。</p><p>例题：<a href="https://codeforces.com/contest/1995/problem/D">https://codeforces.com/contest/1995/problem/D</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, c, k;<br>    std::cin &gt;&gt; n &gt;&gt; c &gt;&gt; k;<br>    std::string s;<br>    std::cin &gt;&gt; s;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; c)</span></span>;<br>    dp[<span class="hljs-number">1</span> &lt;&lt; (s.<span class="hljs-built_in">back</span>() - <span class="hljs-string">&#x27;A&#x27;</span>)]++;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(c)</span></span>;<br>    <span class="hljs-type">int</span> mask = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j + <span class="hljs-number">1</span> &lt; n &amp;&amp; j + <span class="hljs-number">1</span> - i + <span class="hljs-number">1</span> &lt;= k) &#123;<br>            j++;<br>            <span class="hljs-keyword">if</span> (cnt[s[j] - <span class="hljs-string">&#x27;A&#x27;</span>] == <span class="hljs-number">0</span>) &#123;<br>                mask ^= (<span class="hljs-number">1</span> &lt;&lt; s[j] - <span class="hljs-string">&#x27;A&#x27;</span>);<br>            &#125;<br>            cnt[s[j] - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j - i + <span class="hljs-number">1</span> == k) &#123;<br>            dp[mask]++;<br>        &#125;<br>        cnt[s[i] - <span class="hljs-string">&#x27;A&#x27;</span>]--;<br>        <span class="hljs-keyword">if</span> (cnt[s[i] - <span class="hljs-string">&#x27;A&#x27;</span>] == <span class="hljs-number">0</span>) &#123;<br>            mask ^= (<span class="hljs-number">1</span> &lt;&lt; s[i] - <span class="hljs-string">&#x27;A&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; c; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-number">1</span> &lt;&lt; c); j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;&gt; i &amp; <span class="hljs-number">1</span>) &#123;<br>                dp[j] = dp[j] + dp[j ^ (<span class="hljs-number">1</span> &lt;&lt; i)];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = c;<br>    mask = (<span class="hljs-number">1</span> &lt;&lt; c) - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; c); i++) &#123;<br>        <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">0</span>) &#123;<br>            ans = std::<span class="hljs-built_in">min</span>(ans, __builtin_popcount(i ^ mask));<br>        &#125;<br>    &#125;<br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>    std::cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>竞赛</category>
      
      <category>经典题型和trick</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>经典4 倍增</title>
    <link href="/2024/07/26/%E7%BB%8F%E5%85%B84-%E5%80%8D%E5%A2%9E/"/>
    <url>/2024/07/26/%E7%BB%8F%E5%85%B84-%E5%80%8D%E5%A2%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h1><p>给定一个有向图，$n$ 个节点，$n$ 条边（每个点只有一条出边，不一定无环），边权为0或1，询问从每个点出发经过边权为 $0$ 的边的数量或为 $1$ 的数量恰好为 $k$ 时的终点。</p><p>如何我们暴力的在图上沿着边走，时间复杂度会达到 $O(nk)$。无法解决问题。</p><p>这时我们使用倍增，用 $f(i, j)$ 表示第 $i$ 个节点走 $2^j$ 步后到达的点，用 $g(i,j)$ 表示第 $i$ 个节点走了 $2^j$ 步后经历的边权为 $1$ 的边的数量。 这一步预处理时间复杂度为 $O(nlogk)$ ，这样在处理询问，时间复杂度为 $O(klogk)$ 。总时间复杂度 $O((n + k)logk)$ 。</p><p>倍增在处理树上、图上问题往往可以将复杂度由 $O(n)$ 降为 $O(logn)$ ，大大优化时间复杂度。</p><p>例题：2024牛客暑期多校第三次场J题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> n, a, b;<br>    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;<br>    std::string s;<br>    std::string ss;<br>    std::cin &gt;&gt; s;<br>    <span class="hljs-keyword">while</span> (ss.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span> * a + n) &#123;<br>        ss += s;<br>    &#125;<br>    <span class="hljs-type">int</span> m = ss.<span class="hljs-built_in">size</span>();<br><br>    std::vector&lt;std::array&lt;<span class="hljs-type">int</span>, 18&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>);<br>    std::vector&lt;std::array&lt;<span class="hljs-type">int</span>, 18&gt;&gt; <span class="hljs-built_in">cnt</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> cnt1 = <span class="hljs-number">0</span>, cnt0 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &lt; m &amp;&amp; cnt1 &lt; a &amp;&amp; cnt0 &lt; a) &#123;<br>            j++;<br>            <span class="hljs-keyword">if</span> (ss[j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                cnt0++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cnt1++;<br>            &#125;<br>        &#125;<br>        f[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = ((j + <span class="hljs-number">1</span>) % n) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (cnt1 == a) &#123;<br>            cnt[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cnt[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ss[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            cnt0--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cnt1--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">18</span>; j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            f[i][j] = f[f[i][j - <span class="hljs-number">1</span>]][j - <span class="hljs-number">1</span>];<br>            cnt[i][j] = cnt[i][j - <span class="hljs-number">1</span>] + cnt[f[i][j - <span class="hljs-number">1</span>]][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    std::string ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> p = i;<br>        <span class="hljs-type">int</span> cnt0 = <span class="hljs-number">0</span>, cnt1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">17</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-type">int</span> c1 = cnt[p][j];<br>            <span class="hljs-type">int</span> c0 = (<span class="hljs-number">1</span> &lt;&lt; j) - c1;<br>            <span class="hljs-keyword">if</span> (cnt0 + c0 &lt; b &amp;&amp; cnt1 + c1 &lt; b) &#123;<br>                cnt0 += c0;<br>                cnt1 += c1;<br>                p = f[p][j];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt0 + c0 &lt; b) &#123;<br>                ans += <span class="hljs-string">&#x27;1&#x27;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt1 + c1 &lt; b) &#123;<br>                ans += <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>竞赛</category>
      
      <category>经典题型和trick</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>经典3 无向边重定向处理</title>
    <link href="/2024/07/25/%E7%BB%8F%E5%85%B83-%E6%97%A0%E5%90%91%E8%BE%B9%E9%87%8D%E5%AE%9A%E5%90%91%E5%A4%84%E7%90%86/"/>
    <url>/2024/07/25/%E7%BB%8F%E5%85%B83-%E6%97%A0%E5%90%91%E8%BE%B9%E9%87%8D%E5%AE%9A%E5%90%91%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="无向图边的重定向处理"><a href="#无向图边的重定向处理" class="headerlink" title="无向图边的重定向处理"></a>无向图边的重定向处理</h1><p>给定一张无向图 $n$ 个节点和 $m$ 条边，q次询问，每次询问关于其子图，询问子图总点数不超过n。</p><p>处理时我们将整个子图处理出来往往会花费 $O(nm)$ 时间复杂度，这是无法处理的。</p><p>于是我们将无向边重定向，每条边从度数小的节点指向度数大的节点。这样我们可以证明每个节点最多只会有 $O(\sqrt{2m})$ 条出边。这时我们处理出子图就只需要 $O(n\sqrt{m})$ 时间复杂度。从而解决问题。</p><p>证明：若节点在原无向图上的度数小于等于 $\sqrt{2m}$ ，则在新图中的出度一定小于等于 $\sqrt{2m}$ 。</p><p>若节点在原无向图中的度数大于 $\sqrt{2m}$ ，由于一共只有 $m$ 条边，所以所有节点的度数和为 $2m$ ，那么度数大于 $\sqrt{2m}$ 的节点最多只有 $\sqrt{2m}$ 个，又因为我们由度数小的节点指向度数大的节点，所以最多只有 $\sqrt{2m}$ 条出边</p><p>例题：2024牛客暑期多校第二场B题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge &amp;t) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; t.w;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, q;<br>    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    std::vector&lt;std::array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">edge</span>(m + <span class="hljs-number">1</span>);<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        edge[i] = &#123;u, v, w&#125;;<br>        d[u]++;<br>        d[v]++;<br>    &#125;<br>    std::vector&lt;std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> u = edge[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> v = edge[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> w = edge[i][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span> (u &gt; v) &#123;<br>            std::<span class="hljs-built_in">swap</span>(u, v);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (d[u] &gt; d[v]) &#123;<br>            adj[v].<span class="hljs-built_in">push_back</span>(&#123;u, w&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            adj[u].<span class="hljs-built_in">push_back</span>(&#123;v, w&#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    std::<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> k;<br>        std::cin &gt;&gt; k;<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            std::cin &gt;&gt; b[i];<br>            vis[b[i]] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        std::vector&lt;Edge&gt; e;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> u : b) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [v, w] : adj[u]) &#123;<br>                <span class="hljs-keyword">if</span> (vis[v]) &#123;<br>                    e.<span class="hljs-built_in">push_back</span>(&#123;u, v, w&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> find = [&amp;](<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> u) -&gt; <span class="hljs-type">int</span> &#123;<br>            <span class="hljs-keyword">if</span> (p[u] != u) &#123;<br>                p[u] = <span class="hljs-built_in">self</span>(self, p[u]);<br>            &#125;<br>            <span class="hljs-keyword">return</span> p[u];<br>        &#125;;<br><br>        std::<span class="hljs-built_in">sort</span>(e.<span class="hljs-built_in">begin</span>(), e.<span class="hljs-built_in">end</span>());<br>        i64 res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [u, v, w] : e) &#123;<br>            <span class="hljs-type">int</span> fu = <span class="hljs-built_in">find</span>(find, u), fv = <span class="hljs-built_in">find</span>(find, v);<br>            <span class="hljs-keyword">if</span> (fu != fv) &#123;<br>                p[fu] = fv;<br>                res += w;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt == k) &#123;<br>            std::cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> u : b) &#123;<br>            vis[u] = <span class="hljs-number">0</span>;<br>            p[u] = u;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// std::cin &gt;&gt; t;</span><br>    <span class="hljs-keyword">while</span> (t--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>竞赛</category>
      
      <category>经典题型和trick</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>经典2 subset-sum问题</title>
    <link href="/2024/07/24/%E7%BB%8F%E5%85%B82/"/>
    <url>/2024/07/24/%E7%BB%8F%E5%85%B82/</url>
    
    <content type="html"><![CDATA[<h1 id="subset-sum问题"><a href="#subset-sum问题" class="headerlink" title="subset-sum问题"></a>subset-sum问题</h1><p>给定 $m$ 堆石头，每堆 $a_i$ 个石头，一共n个石头。是否可以从中选出部分堆其总和为k个。</p><p>使用 $dp$ 方法解决，$dp[i][j]$ 表示在前 $i$ 个石头中选是否可以选出总数为 $j$ 结果。转移方程 $dp[i][j] &#x3D; dp[i - 1][j] | dp[i - 1][j - a_i]$ ，时间复杂度 $O(n^2)$ 。</p><p>当 $n$ 过大时 ，上述方法无法解决。注意到石头总和为 $n$ 个，那么使用二进制优化，如果有三堆数量相同，可以合并其中两堆，堆的数量 $m$ 会降到 $\sqrt{n}$，时间复杂度降为 $O(n\sqrt{n})$</p><p>更进一步，我们可以使用 $bitset$ 优化 $dp$ 过程。</p><p>例题：<a href="https://codeforces.com/problemset/problem/1381/B">https://codeforces.com/problemset/problem/1381/B</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n * <span class="hljs-number">2</span>; i++) &#123;<br>        std::cin &gt;&gt; a[i];<br>    &#125;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>)</span></span>;<br>    v[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n * <span class="hljs-number">2</span>; i++) &#123;<br>        mx = std::<span class="hljs-built_in">max</span>(mx, a[i]);<br>        <span class="hljs-keyword">if</span> (mx == a[i]) &#123;<br>            v[i - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n * <span class="hljs-number">2</span>; i++) &#123;<br>        <span class="hljs-keyword">auto</span> ndp = dp;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (v[i] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">if</span> (v[j]) &#123;<br>                    len = i - j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = len; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (dp[j - len] == <span class="hljs-number">1</span>) &#123;<br>                ndp[j] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        std::<span class="hljs-built_in">swap</span>(dp, ndp);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[n]) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>    std::cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>竞赛</category>
      
      <category>经典题型和trick</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>经典1</title>
    <link href="/2024/07/23/%E7%BB%8F%E5%85%B81/"/>
    <url>/2024/07/23/%E7%BB%8F%E5%85%B81/</url>
    
    <content type="html"><![CDATA[<p>给定 $n$ 堆东西，每堆有 $a_i$ 个且种类不同。进行如下操作：</p><p>每次从 $n$ 堆东西中选出 $k$ 堆，每堆取走一个。</p><p>询问最多能进行多少次操作。</p><p>结论：设 $x$ 为操作次数，则 $\sum_{i&#x3D;1}^nmin(a_i, x) \geq kx$ 为 $x$ 合法的充分必要条件。</p><p>必要性显然，下证充分性。</p><p>每次将东西最多的 $k$ 个堆取出一个。贪心成立性的原因在于每次相当于每次将 $a_1, a_2, . . . , a_n$中最大的 $k$ 个元素减一，更新后的数组 $a_i^{‘}$ 满足 $∑^n_{ i&#x3D;1} min(a ^′_i , x − 1) ≥ (x − 1)k$。由数学归纳法可知正确性。</p><p>同时我们可以知道当可以取 $x$ 次一定可以取 $x - 1$ 次，则说明答案具有二段性，可以二分答案找出其中的可操作次数的最大值。</p><p>例题：2024牛客暑期多校第三场A题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> n, L, R;<br>    std::cin &gt;&gt; n &gt;&gt; L &gt;&gt; R;<br>    <span class="hljs-function">std::vector&lt;i64&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        std::cin &gt;&gt; a[i];<br>        a[i] = (a[i] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br><br>    i64 cnt = (n - R + (R - L - <span class="hljs-number">1</span>)) / (R - L);<br>    i64 l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1E9</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        i64 mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        i64 sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum += std::<span class="hljs-built_in">min</span>(a[i], mid);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum &gt;= mid * L) &#123;<br>            l = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (l &gt;= cnt) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>竞赛</category>
      
      <category>经典题型和trick</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客 2024暑期多校第三场题解</title>
    <link href="/2024/07/23/%E7%89%9B%E5%AE%A2-2024%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA%E9%A2%98%E8%A7%A3/"/>
    <url>/2024/07/23/%E7%89%9B%E5%AE%A2-2024%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客 2024暑期多校第一场题解</title>
    <link href="/2024/07/16/%E7%89%9B%E5%AE%A2-2024%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%A2%98%E8%A7%A3/"/>
    <url>/2024/07/16/%E7%89%9B%E5%AE%A2-2024%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="A-A-Bit-Common"><a href="#A-A-Bit-Common" class="headerlink" title="A A Bit Common"></a>A A Bit Common</h1><p>我们将数字集合分为两个集合，一个集合内为最低位为0，记为 $S_0$。另一个集合内为最低位为1，记为$S_1$。</p><p>我们划分 $k$ 个数在集合 $S_1$ 中，则集合 $S_0$ 中有 $n - k$ 个数。由于最终子序列 $AND$ 在一起为1，所有集合 $S_0$ 中的数一定不在子序列中。</p><p>考虑集合 $S_0$ 中除了最低位必须为0，没有其他限制，所以每个数有 $2^{m - 1}$ 种方案，一共 $(2^{m - 1})^{n - k}$ 种。</p><p>子序列一定是集合 $S_1$ 的子集，由于 $AND$ 的性质，将集合 $S_1$ 中不在子序列中的数加入子序列，结果依然为1。所以可以直接将子序列认定为集合 $S_1$ 。即只要所有二进制最低位为 1 的数 $AND$ 和是 1 就能满足条件。</p><p>集合 $S_1$ 这些数除了最低位的 AND 和 都要是 0，也就是每一位上这些数都至少有一个是 0。考虑使得一位 $AND$ 为0，有 $2^k-1$ 种方案，一共 $m - 1$ 位，所以集合 $S_1$ 共 $(2^k - 1) ^ {m - 1}$ 种方案。</p><p>最后考虑到从 $n$ 个数中选出 $k$ 个在集合 $S_1$ 中，即 $C_n^k$ 种方案。</p><p>最终方案数是 $C_n^k(2^{m-1})^{n-k}(2^k-1)^{m-1}$ ，对 k 从 1 到 n 求和即可。</p><p>由于模数不一定互质，使用递推法求组合数。时间复杂度 $O(n^2)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k) &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>)<br>            res = (i64)res * a % p;<br>        a = (i64)a * a % p;<br>        k = k &gt;&gt; <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, mod;<br>    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;<br><br>    std::vector&lt;std::vector&lt;i64&gt;&gt; <span class="hljs-built_in">c</span>(n + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;i64&gt;(n + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!j) &#123;<br>                c[i][j] = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % mod;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    i64 ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> m2 = <span class="hljs-built_in">qmi</span>(<span class="hljs-number">2</span>, m - <span class="hljs-number">1</span>, mod);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        ans = (ans + (c[n][i] * <span class="hljs-built_in">qmi</span>(m2, n - i, mod) % mod) * <span class="hljs-built_in">qmi</span>(<span class="hljs-built_in">qmi</span>(<span class="hljs-number">2</span>, i, mod) - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>, mod) % mod) % mod;<br>    &#125;<br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// std::cin &gt;&gt; t;</span><br>    <span class="hljs-keyword">while</span> (t--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-A-Bit-More-Common"><a href="#B-A-Bit-More-Common" class="headerlink" title="B A Bit More Common"></a>B A Bit More Common</h1><p>同题 A 将数字集合分为两个集合 $S_0$ 和 $S_1$ ，我们划分 $k$ 个数在集合 $S_1$ 中，则集合 $S_0$ 中有 $n - k$ 个数。由于最终两个子序列 $AND$ 在一起分别为1，所有集合 $S_0$ 中的数一定不在任意一个子序列中。</p><p>考虑集合 $S_0$ 中除了最低位必须为0，没有其他限制，所以每个数有 $2^{m - 1}$ 种方案，一共 $(2^{m - 1})^{n - k}$ 种。</p><p>一个子序列一定是集合 $S_1$ 的真子集（两个子序列不可能同时为 $S_1$），由于 $AND$ 的性质，将集合 $S_1$ 中不在子序列中的数加入子序列，结果依然为1，这样就可以组成另一个子序列。所以 B 题可以转化为求集合 $S_1$ 中存在真子集 $AND$ 结果为1的方案数。</p><p>考虑 A 题中已经得到集合 $S_1$ 中存在子集 $AND$ 结果为1的方案数，为$(2^k - 1) ^ {m - 1}$ 种，减去方案中合法子集一定为集合 $S_1$ 本身的方案数即可。</p><p>要让集合 $S_1$ 中每个的集合成员都一定要在子序列中，则在 $m-1$ 位中一定有几位只有在这个数的位置上为0，而其余 $k-1$ 个集合成员在这一位为1。</p><p>我们每次从 $m-1$  位中选出 $j$ 位，表示这 $j$ 位只在 $k$ 个数中某一位为0，其余为1，且 $k$ 个数至少分到 $j$ 个中的一位。这就是将不同的小球放在不同的盒子中，且盒子不能为空，答案为 $S[j][k] * k!$ ，其中 $S$ 表示第二类斯特林数。剩下的 $m - 1 - j$ 位只要保证 $k$ 个数中存在至少两个数这一位位为0即可，即为 $(2^k-1-k)^{m-1-j}$ 种方案。</p><p>所有不满足条件的总方案数为 $\sum_k^{m-1} C_{m-1}^jS[j][k]*k!(2^k-1-k)^{m-1-j}$ ，减去这部分得到 $S_1$ 集合的合法方案数，即$$(2^k - 1) ^ {m - 1} - \sum_k^{m-1} C_{m-1}^jS[j][k]*k!(2^k-1-k)^{m-1-j} (k \le j\le m-1)$$</p><p>将 $k$ 从2循环到n求和即可，得到</p><p>$$\sum_2^n (C_n^k(2^{m - 1})^{n - k} * ((2^k - 1) ^ {m - 1} - \sum_k^{m-1} (C_{m-1}^jS[j][k]*k!(2^k-1-k)^{m-1-j})))$$</p><p>预处理出组合数，斯特林数，以及对应的2的幂次，注意取模，时间复杂度 $O(nm)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k) &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>)<br>            res = (i64)res * a % p;<br>        a = (i64)a * a % p;<br>        k = k &gt;&gt; <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5001</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, mod;<br>    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;<br><br>    std::vector&lt;std::vector&lt;i64&gt;&gt; <span class="hljs-built_in">c</span>(N, std::<span class="hljs-built_in">vector</span>&lt;i64&gt;(N));<br>    std::vector&lt;std::vector&lt;i64&gt;&gt; <span class="hljs-built_in">S</span>(N, std::<span class="hljs-built_in">vector</span>&lt;i64&gt;(N));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!j) &#123;<br>                c[i][j] = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % mod;<br>            &#125;<br>        &#125;<br>    &#125;<br>    S[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; N; j++) &#123;<br>            S[i][j] = (S[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + j * S[i - <span class="hljs-number">1</span>][j]) % mod;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">std::vector&lt;i64&gt; <span class="hljs-title">A</span><span class="hljs-params">(N)</span>, <span class="hljs-title">B</span><span class="hljs-params">(N)</span></span>;<br>    A[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) &#123;<br>        A[i] = A[i - <span class="hljs-number">1</span>] * i % mod;<br>    &#125;<br><br>    B[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) &#123;<br>        B[i] = B[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> % mod;<br>    &#125;<br><br>    i64 ans = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        i64 a = <span class="hljs-built_in">qmi</span>(((B[i] - <span class="hljs-number">1</span>) % mod + mod) % mod, m - <span class="hljs-number">1</span>, mod);<br>        i64 d = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> cur = ((B[i] - <span class="hljs-number">1</span> - i) % mod + mod) % mod;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m - <span class="hljs-number">1</span>; j &gt;= i; j--) &#123;<br>            <span class="hljs-keyword">if</span> (m - <span class="hljs-number">1</span> - j &gt; <span class="hljs-number">0</span>) &#123;<br>                d = d * cur % mod;<br>            &#125;<br>            i64 b = ((c[m - <span class="hljs-number">1</span>][j] * S[j][i] % mod) * A[i] % mod) * d % mod;<br>            a = ((a - b) % mod + mod) % mod;<br>        &#125;<br>        i64 res = ((i64)c[n][i] * <span class="hljs-built_in">qmi</span>(B[m - <span class="hljs-number">1</span>], n - i, mod) % mod) * a % mod;<br>        ans = (ans + res) % mod;<br>    &#125;<br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// std::cin &gt;&gt; t;</span><br>    <span class="hljs-keyword">while</span> (t--)<br>        <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>牛客</category>
      
      <category>2024暑期多校</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客 2024暑期多校题解</title>
    <link href="/2024/07/07/%E7%89%9B%E5%AE%A2-2024%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E9%A2%98%E8%A7%A3/"/>
    <url>/2024/07/07/%E7%89%9B%E5%AE%A2-2024%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>记录一下牛客 2024 暑期多校题解。</p>]]></content>
    
    
    <categories>
      
      <category>牛客</category>
      
      <category>2024暑期多校</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/07/05/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/07/05/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/07/05/hello-world/"/>
    <url>/2024/07/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
